<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  A Deep Dive into EVM Gas Optimization · Axat Bhardwaj
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Axat Bhardwaj">
<meta name="description" content="
  EVM Gas optimization
  
    
    Link to heading
  


  Main Gas optimization areas in solidity
  
    
    Link to heading
  


  Storage
  
    
    Link to heading
  


Saving one variable in storage costs 20,000 gas
5,000 gas when we rewrite the variable
reading from the slot take 200 gas
But storage variable declaration doesn&rsquo;t cost anything, as there&rsquo;s no initialization


  Tips
  
    
    Link to heading
  


always save a storage variable in memory in a function
if you wanna update a storage variable then first calculate everything in the memory variables
organize &amp; try to pack two or more storage variables into one it&rsquo;s much cheaper
also while using structs, try to pack them


  Refunds
  
    
    Link to heading
  


Free storage slot by zeroing corresponding variables as soon as you don&rsquo;t need them anymore. This will refund 15,000 of gas.
Removing a contract by using Selfdestruct opcodes refunds 24,000 gas. But a refund must not surpass half the gas that the ongoing contract call uses.


  Data types and packing
  
    
    Link to heading
  


Use bytes32 whenever possible, because it is the most optimized storage type.
If the length of bytes can be limited, use the lowest amount possible from bytes1 to bytes32.
Using bytes32 is cheaper than using string
Variable packing only occurs in storage — memory and call data does not get packed.
You will not save space trying to pack function arguments or local variables
Storing a small number in a uint8 variable is not cheaper than storing it in uint256 because the number in uint8 is padded with numbers to fill 32 bytes.


  Inheritance
  
    
    Link to heading
  


when we extend a contract, the variables in the child can be packed with the variables in the parent.
The order of variables is determined by C3 linearization, all you need to know is that child variables come after parent variables.


  Memory vs Storage
  
    
    Link to heading
  


copying between the memory and storage will cost some gas, so don&rsquo;t copy arrays from storage to memory, use a storage pointer.
the cost of memory is complicated. you &ldquo;buy&rdquo; it in chunks, the cost of which will go up quadratically after a while
Try adjusting the location of your variables by playing with the keywords &ldquo;storage&rdquo; and &ldquo;memory&rdquo;. Depending on the size and number of copying operations between Storage and memory, switching to memory may or may not give improvements. All this is because of varying memory costs. So optimizing here is not that obvious and every case has to be considered individually.


  Variables
  
    
    Link to heading
  


Avoid public variables
Use global variables efficiently
it is good to use global variables with private visibility as it saves gas
Use events rather than storing data
Use memory arrays efficiently
Use return values efficiently
A simple optimization in Solidity consists of naming the return value of a function. It is not needed to create a local variable then.


  Mapping vs Array
  
    
    Link to heading
  


Use mapping whenever possible, it&rsquo;s cheap instead of the array
But an array could be a good choice if you have a small array


  Fixed vs Dynamic
  
    
    Link to heading
  


Fixed size variables are always cheaper than dynamic ones.
It&rsquo;s good to use memory arrays if the size of the array is known, fixed-size memory arrays can be used to save gas.
If we know how long an array should be, we specify a fixed size
This same rule applies to strings. A string or bytes variable is dynamically sized; we should use a byte32 if our string is short enough to fit.
If we absolutely need a dynamic array, it is best to structure our functions to be additive instead of subtractive. Extending an array costs constant gas whereas truncating an array costs linear gas.


  Functions
  
    
    Link to heading
  


use external most of the time whenever possible
Each position will have an extra 22 gas, so

Reduce public variables
Put often-called functions earlier


reduce the parameters if possible (Bigger input data increases gas because more things will be stored in memory)
payable function saves some gas as compared to non-payable functions (as the compiler won&rsquo;t have to check)


  View Functions
  
    
    Link to heading
  


You are not paying for view functions but this doesn&rsquo;t mean they aren&rsquo;t consuming gas, they do.
it cost gas when calling in a tx


  Loops
  
    
    Link to heading
  


use memory variables in loops
try to avoid unbounded loops
write uint256 index; instead of writing uint256 index = 0; as being a uint256, it will be 0 by default so you can save some gas by avoiding initialization.
if you put &#43;&#43; before i it costs less gas


  Operations
  
    
    Link to heading
  


  Order
  
    
    Link to heading
  


Order cheap functions before

f(x) is cheap
g(y) is expensive
ordering should be
f(x) || g(y)
f(x) &amp;&amp; g(y)




  Use Short-Circuiting rules to your advantage
  
    
    Link to heading
  

When using logical disjunction (||), logical conjunction (&amp;&amp;), make sure to order your functions correctly for optimal gas usage. In logical disjunction (OR), if the first function resolves to true, the second one won’t be executed and hence save you gas. In logical disjunction (AND), if the first function evaluates to false, the next function won’t be evaluated. Therefore, you should order your functions accordingly in your solidity code to reduce the probability of needing to evaluate the second function.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="A Deep Dive into EVM Gas Optimization">
  <meta name="twitter:description" content="EVM Gas optimization Link to heading Main Gas optimization areas in solidity Link to heading Storage Link to heading Saving one variable in storage costs 20,000 gas 5,000 gas when we rewrite the variable reading from the slot take 200 gas But storage variable declaration doesn’t cost anything, as there’s no initialization Tips Link to heading always save a storage variable in memory in a function if you wanna update a storage variable then first calculate everything in the memory variables organize &amp; try to pack two or more storage variables into one it’s much cheaper also while using structs, try to pack them Refunds Link to heading Free storage slot by zeroing corresponding variables as soon as you don’t need them anymore. This will refund 15,000 of gas. Removing a contract by using Selfdestruct opcodes refunds 24,000 gas. But a refund must not surpass half the gas that the ongoing contract call uses. Data types and packing Link to heading Use bytes32 whenever possible, because it is the most optimized storage type. If the length of bytes can be limited, use the lowest amount possible from bytes1 to bytes32. Using bytes32 is cheaper than using string Variable packing only occurs in storage — memory and call data does not get packed. You will not save space trying to pack function arguments or local variables Storing a small number in a uint8 variable is not cheaper than storing it in uint256 because the number in uint8 is padded with numbers to fill 32 bytes. Inheritance Link to heading when we extend a contract, the variables in the child can be packed with the variables in the parent. The order of variables is determined by C3 linearization, all you need to know is that child variables come after parent variables. Memory vs Storage Link to heading copying between the memory and storage will cost some gas, so don’t copy arrays from storage to memory, use a storage pointer. the cost of memory is complicated. you “buy” it in chunks, the cost of which will go up quadratically after a while Try adjusting the location of your variables by playing with the keywords “storage” and “memory”. Depending on the size and number of copying operations between Storage and memory, switching to memory may or may not give improvements. All this is because of varying memory costs. So optimizing here is not that obvious and every case has to be considered individually. Variables Link to heading Avoid public variables Use global variables efficiently it is good to use global variables with private visibility as it saves gas Use events rather than storing data Use memory arrays efficiently Use return values efficiently A simple optimization in Solidity consists of naming the return value of a function. It is not needed to create a local variable then. Mapping vs Array Link to heading Use mapping whenever possible, it’s cheap instead of the array But an array could be a good choice if you have a small array Fixed vs Dynamic Link to heading Fixed size variables are always cheaper than dynamic ones. It’s good to use memory arrays if the size of the array is known, fixed-size memory arrays can be used to save gas. If we know how long an array should be, we specify a fixed size This same rule applies to strings. A string or bytes variable is dynamically sized; we should use a byte32 if our string is short enough to fit. If we absolutely need a dynamic array, it is best to structure our functions to be additive instead of subtractive. Extending an array costs constant gas whereas truncating an array costs linear gas. Functions Link to heading use external most of the time whenever possible Each position will have an extra 22 gas, so Reduce public variables Put often-called functions earlier reduce the parameters if possible (Bigger input data increases gas because more things will be stored in memory) payable function saves some gas as compared to non-payable functions (as the compiler won’t have to check) View Functions Link to heading You are not paying for view functions but this doesn’t mean they aren’t consuming gas, they do. it cost gas when calling in a tx Loops Link to heading use memory variables in loops try to avoid unbounded loops write uint256 index; instead of writing uint256 index = 0; as being a uint256, it will be 0 by default so you can save some gas by avoiding initialization. if you put &#43;&#43; before i it costs less gas Operations Link to heading Order Link to heading Order cheap functions before f(x) is cheap g(y) is expensive ordering should be f(x) || g(y) f(x) &amp;&amp; g(y) Use Short-Circuiting rules to your advantage Link to heading When using logical disjunction (||), logical conjunction (&amp;&amp;), make sure to order your functions correctly for optimal gas usage. In logical disjunction (OR), if the first function resolves to true, the second one won’t be executed and hence save you gas. In logical disjunction (AND), if the first function evaluates to false, the next function won’t be evaluated. Therefore, you should order your functions accordingly in your solidity code to reduce the probability of needing to evaluate the second function.">

<meta property="og:url" content="https://axatbhardwaj.eth.limo/posts/evm-gas-optimizations/">
  <meta property="og:site_name" content="Axat Bhardwaj">
  <meta property="og:title" content="A Deep Dive into EVM Gas Optimization">
  <meta property="og:description" content="EVM Gas optimization Link to heading Main Gas optimization areas in solidity Link to heading Storage Link to heading Saving one variable in storage costs 20,000 gas 5,000 gas when we rewrite the variable reading from the slot take 200 gas But storage variable declaration doesn’t cost anything, as there’s no initialization Tips Link to heading always save a storage variable in memory in a function if you wanna update a storage variable then first calculate everything in the memory variables organize &amp; try to pack two or more storage variables into one it’s much cheaper also while using structs, try to pack them Refunds Link to heading Free storage slot by zeroing corresponding variables as soon as you don’t need them anymore. This will refund 15,000 of gas. Removing a contract by using Selfdestruct opcodes refunds 24,000 gas. But a refund must not surpass half the gas that the ongoing contract call uses. Data types and packing Link to heading Use bytes32 whenever possible, because it is the most optimized storage type. If the length of bytes can be limited, use the lowest amount possible from bytes1 to bytes32. Using bytes32 is cheaper than using string Variable packing only occurs in storage — memory and call data does not get packed. You will not save space trying to pack function arguments or local variables Storing a small number in a uint8 variable is not cheaper than storing it in uint256 because the number in uint8 is padded with numbers to fill 32 bytes. Inheritance Link to heading when we extend a contract, the variables in the child can be packed with the variables in the parent. The order of variables is determined by C3 linearization, all you need to know is that child variables come after parent variables. Memory vs Storage Link to heading copying between the memory and storage will cost some gas, so don’t copy arrays from storage to memory, use a storage pointer. the cost of memory is complicated. you “buy” it in chunks, the cost of which will go up quadratically after a while Try adjusting the location of your variables by playing with the keywords “storage” and “memory”. Depending on the size and number of copying operations between Storage and memory, switching to memory may or may not give improvements. All this is because of varying memory costs. So optimizing here is not that obvious and every case has to be considered individually. Variables Link to heading Avoid public variables Use global variables efficiently it is good to use global variables with private visibility as it saves gas Use events rather than storing data Use memory arrays efficiently Use return values efficiently A simple optimization in Solidity consists of naming the return value of a function. It is not needed to create a local variable then. Mapping vs Array Link to heading Use mapping whenever possible, it’s cheap instead of the array But an array could be a good choice if you have a small array Fixed vs Dynamic Link to heading Fixed size variables are always cheaper than dynamic ones. It’s good to use memory arrays if the size of the array is known, fixed-size memory arrays can be used to save gas. If we know how long an array should be, we specify a fixed size This same rule applies to strings. A string or bytes variable is dynamically sized; we should use a byte32 if our string is short enough to fit. If we absolutely need a dynamic array, it is best to structure our functions to be additive instead of subtractive. Extending an array costs constant gas whereas truncating an array costs linear gas. Functions Link to heading use external most of the time whenever possible Each position will have an extra 22 gas, so Reduce public variables Put often-called functions earlier reduce the parameters if possible (Bigger input data increases gas because more things will be stored in memory) payable function saves some gas as compared to non-payable functions (as the compiler won’t have to check) View Functions Link to heading You are not paying for view functions but this doesn’t mean they aren’t consuming gas, they do. it cost gas when calling in a tx Loops Link to heading use memory variables in loops try to avoid unbounded loops write uint256 index; instead of writing uint256 index = 0; as being a uint256, it will be 0 by default so you can save some gas by avoiding initialization. if you put &#43;&#43; before i it costs less gas Operations Link to heading Order Link to heading Order cheap functions before f(x) is cheap g(y) is expensive ordering should be f(x) || g(y) f(x) &amp;&amp; g(y) Use Short-Circuiting rules to your advantage Link to heading When using logical disjunction (||), logical conjunction (&amp;&amp;), make sure to order your functions correctly for optimal gas usage. In logical disjunction (OR), if the first function resolves to true, the second one won’t be executed and hence save you gas. In logical disjunction (AND), if the first function evaluates to false, the next function won’t be evaluated. Therefore, you should order your functions accordingly in your solidity code to reduce the probability of needing to evaluate the second function.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-06T00:15:00+05:30">
    <meta property="article:modified_time" content="2025-07-06T00:15:00+05:30">
    <meta property="article:tag" content="Solidity">
    <meta property="article:tag" content="Gas Optimization">
    <meta property="article:tag" content="EVM">
    <meta property="article:tag" content="Blockchain">




<link rel="canonical" href="https://axatbhardwaj.eth.limo/posts/evm-gas-optimizations/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6445a802b9389c9660e1b07b724dcf5718b1065ed2d71b4eeaf981cc7cc5fc46.css" integrity="sha256-ZEWoArk4nJZg4bB7ck3PVxixBl7S1xtO6vmBzHzF/EY=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/img/avtr.png" sizes="any">
<link rel="icon" type="image/png" href="/img/avtr.png" sizes="32x32">
<link rel="icon" type="image/png" href="/img/avtr.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://axatbhardwaj.eth.limo/">
      Axat Bhardwaj
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/resume/">Resume</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://axatbhardwaj.eth.limo/posts/evm-gas-optimizations/">
              A Deep Dive into EVM Gas Optimization
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-07-06T00:15:00&#43;05:30">
                July 6, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              6-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/solidity/">Solidity</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/gas-optimization/">Gas Optimization</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/evm/">EVM</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/blockchain/">Blockchain</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="evm-gas-optimization">
  EVM Gas optimization
  <a class="heading-link" href="#evm-gas-optimization">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="main-gas-optimization-areas-in-solidity">
  Main Gas optimization areas in solidity
  <a class="heading-link" href="#main-gas-optimization-areas-in-solidity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="storage">
  Storage
  <a class="heading-link" href="#storage">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Saving one variable in storage costs 20,000 gas</li>
<li>5,000 gas when we rewrite the variable</li>
<li>reading from the slot take 200 gas</li>
<li>But storage variable declaration doesn&rsquo;t cost anything, as there&rsquo;s no initialization</li>
</ul>
<h3 id="tips">
  Tips
  <a class="heading-link" href="#tips">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>always save a storage variable in memory in a function</li>
<li>if you wanna update a storage variable then first calculate everything in the memory variables</li>
<li>organize &amp; try to pack two or more storage variables into one it&rsquo;s much cheaper</li>
<li>also while using structs, try to pack them</li>
</ul>
<h3 id="refunds">
  Refunds
  <a class="heading-link" href="#refunds">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Free storage slot by zeroing corresponding variables as soon as you don&rsquo;t need them anymore. This will refund 15,000 of gas.</li>
<li>Removing a contract by using <code>Selfdestruct</code> opcodes refunds 24,000 gas. But a refund must not surpass half the gas that the ongoing contract call uses.</li>
</ul>
<h3 id="data-types-and-packing">
  Data types and packing
  <a class="heading-link" href="#data-types-and-packing">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Use bytes32 whenever possible, because it is the most optimized storage type.</li>
<li>If the length of bytes can be limited, use the lowest amount possible from bytes1 to bytes32.</li>
<li>Using bytes32 is cheaper than using string</li>
<li>Variable packing only occurs in storage — memory and call data does not get packed.</li>
<li>You will not save space trying to pack function arguments or local variables</li>
<li>Storing a small number in a uint8 variable is not cheaper than storing it in uint256 because the number in uint8 is padded with numbers to fill 32 bytes.</li>
</ul>
<h3 id="inheritance">
  Inheritance
  <a class="heading-link" href="#inheritance">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>when we extend a contract, the variables in the child can be packed with the variables in the parent.</li>
<li>The order of variables is determined by <a href="https://en.wikipedia.org/wiki/C3_linearization"  class="external-link" target="_blank" rel="noopener">C3 linearization</a>, all you need to know is that child variables come after parent variables.</li>
</ul>
<h3 id="memory-vs-storage">
  Memory vs Storage
  <a class="heading-link" href="#memory-vs-storage">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>copying between the memory and storage will cost some gas, so don&rsquo;t copy arrays from storage to memory, use a <a href="https://blog.b9lab.com/storage-pointers-in-solidity-7dcfaa536089"  class="external-link" target="_blank" rel="noopener">storage pointer</a>.</li>
<li>the cost of memory is complicated. you &ldquo;buy&rdquo; it in chunks, the cost of which will go up quadratically after a while</li>
<li>Try adjusting the location of your variables by playing with the keywords &ldquo;storage&rdquo; and &ldquo;memory&rdquo;. Depending on the size and number of copying operations between Storage and memory, switching to memory may or may not give improvements. All this is because of varying memory costs. So optimizing here is not that obvious and every case has to be considered individually.</li>
</ul>
<h2 id="variables">
  Variables
  <a class="heading-link" href="#variables">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Avoid public variables</li>
<li>Use global variables efficiently</li>
<li>it is good to use global variables with private visibility as it saves gas</li>
<li>Use events rather than storing data</li>
<li>Use memory arrays efficiently</li>
<li>Use return values efficiently</li>
<li>A simple optimization in Solidity consists of naming the return value of a function. It is not needed to create a local variable then.</li>
</ul>
<h3 id="mapping-vs-array">
  Mapping vs Array
  <a class="heading-link" href="#mapping-vs-array">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Use mapping whenever possible, it&rsquo;s cheap instead of the array</li>
<li>But an array could be a good choice if you have a small array</li>
</ul>
<h3 id="fixed-vs-dynamic">
  Fixed vs Dynamic
  <a class="heading-link" href="#fixed-vs-dynamic">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Fixed size variables are always cheaper than dynamic ones.</li>
<li>It&rsquo;s good to use memory arrays if the size of the array is known, fixed-size memory arrays can be used to save gas.</li>
<li>If we know how long an array should be, we specify a fixed size</li>
<li>This same rule applies to strings. A string or bytes variable is dynamically sized; we should use a byte32 if our string is short enough to fit.</li>
<li>If we absolutely need a dynamic array, it is best to structure our functions to be additive instead of subtractive. Extending an array costs constant gas whereas truncating an array costs linear gas.</li>
</ul>
<h2 id="functions">
  Functions
  <a class="heading-link" href="#functions">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>use external most of the time whenever possible</li>
<li>Each position will have an extra 22 gas, so
<ul>
<li>Reduce public variables</li>
<li>Put often-called functions earlier</li>
</ul>
</li>
<li>reduce the parameters if possible (Bigger input data increases gas because more things will be stored in memory)</li>
<li>payable function saves some gas as compared to non-payable functions (as the compiler won&rsquo;t have to check)</li>
</ul>
<h3 id="view-functions">
  View Functions
  <a class="heading-link" href="#view-functions">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>You are not paying for view functions but this doesn&rsquo;t mean they aren&rsquo;t consuming gas, they do.</li>
<li>it cost gas when calling in a tx</li>
</ul>
<h2 id="loops">
  Loops
  <a class="heading-link" href="#loops">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>use memory variables in loops</li>
<li>try to avoid unbounded loops</li>
<li>write uint256 index; instead of writing uint256 index = 0; as being a uint256, it will be 0 by default so you can save some gas by avoiding initialization.</li>
<li>if you put <code>++</code> before <code>i</code> it costs less gas</li>
</ul>
<h2 id="operations">
  Operations
  <a class="heading-link" href="#operations">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="order">
  Order
  <a class="heading-link" href="#order">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Order cheap functions before
<ul>
<li>f(x) is cheap</li>
<li>g(y) is expensive</li>
<li>ordering should be</li>
<li>f(x) || g(y)</li>
<li>f(x) &amp;&amp; g(y)</li>
</ul>
</li>
</ul>
<h3 id="use-short-circuiting-rules-to-your-advantage">
  Use Short-Circuiting rules to your advantage
  <a class="heading-link" href="#use-short-circuiting-rules-to-your-advantage">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>When using logical disjunction (||), logical conjunction (&amp;&amp;), make sure to order your functions correctly for optimal gas usage. In logical disjunction (OR), if the first function resolves to true, the second one won’t be executed and hence save you gas. In logical disjunction (AND), if the first function evaluates to false, the next function won’t be evaluated. Therefore, you should order your functions accordingly in your solidity code to reduce the probability of needing to evaluate the second function.</p>
<h3 id="using-unchecked">
  Using unchecked
  <a class="heading-link" href="#using-unchecked">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Use unchecked for arithmetic where you are sure it won&rsquo;t over or underflow, saving gas costs for checks added from solidity v0.8.0.</p>
<h2 id="other-optimizations">
  Other Optimizations
  <a class="heading-link" href="#other-optimizations">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Remove the dead code</li>
<li>Use different solidity versions and try</li>
<li><code>EXTCODESIZE</code> is quite expensive, this is used for calls between contracts, the only option we see to optimize the code in this regard is minimizing the number of calls to other contracts and libraries.</li>
</ul>
<h3 id="libraries">
  Libraries
  <a class="heading-link" href="#libraries">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>When a public function of a library is called, the bytecode of that function is not made part of a client contract. Thus, complex logic should be put in libraries (but there is also the cost of calling the library function)</p>
<h3 id="errors">
  Errors
  <a class="heading-link" href="#errors">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Use &ldquo;require&rdquo; for all runtime conditions validations that can&rsquo;t be pre-validated on the compile time. And &ldquo;assert&rdquo; should be used only for static validation that normally fails never fail on a properly functioning code.</li>
<li>string size in require statements can be shortened to reduce gas.</li>
<li>A failing &ldquo;assert&rdquo; consumer all the gas available to the call, while &ldquo;require&rdquo; doesn&rsquo;t consume any.</li>
</ul>
<h3 id="hash-functions">
  Hash functions
  <a class="heading-link" href="#hash-functions">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>keccak256: 30 gas + 6 gas for each word of input data</li>
<li>sha256: 60 gas + 12 gas for each word of input data</li>
<li>ripemd160: 600 gas + 120 gas for each word of input data</li>
<li>So if you don&rsquo;t have any specific reasons to select another hash function, just use keccak256</li>
</ul>
<h3 id="use-erc1167-to-deploy-the-same-contract-many-times">
  Use ERC1167 To Deploy the same Contract many times
  <a class="heading-link" href="#use-erc1167-to-deploy-the-same-contract-many-times">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>EIP1167 minimal proxy contract is a standardized, gas-efficient way to deploy a bunch of contract clones from a factory. EIP1167 not only minimizes length, but it is also literally a “minimal” proxy that does nothing but proxying. It minimizes trust. Unlike other upgradable proxy contracts that rely on the honesty of their administrator (who can change the implementation), the address in EIP1167 is hardcoded in bytecode and remain unchangeable</p>
<h2 id="merkle-proof">
  Merkle proof
  <a class="heading-link" href="#merkle-proof">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>A Merkle tree can be used to prove the validity of a large amount of data using a small amount of data.</li>
</ul>
<h2 id="tools-for-estimating-gas">
  Tools for estimating gas
  <a class="heading-link" href="#tools-for-estimating-gas">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Remix</li>
<li>Truffle</li>
<li>Eth Gas reporter</li>
</ul>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2025
     Axat Bhardwaj 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
