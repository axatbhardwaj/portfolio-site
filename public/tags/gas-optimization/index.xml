<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gas Optimization on Axat Bhardwaj</title>
    <link>https://axatbhardwaj.eth.limo/tags/gas-optimization/</link>
    <description>Recent content in Gas Optimization on Axat Bhardwaj</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 06 Jul 2025 00:15:00 +0530</lastBuildDate>
    <atom:link href="https://axatbhardwaj.eth.limo/tags/gas-optimization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A Deep Dive into EVM Gas Optimization</title>
      <link>https://axatbhardwaj.eth.limo/posts/evm-gas-optimizations/</link>
      <pubDate>Sun, 06 Jul 2025 00:15:00 +0530</pubDate>
      <guid>https://axatbhardwaj.eth.limo/posts/evm-gas-optimizations/</guid>
      <description>&lt;h1 id=&#34;evm-gas-optimization&#34;&gt;&#xA;  EVM Gas optimization&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#evm-gas-optimization&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;main-gas-optimization-areas-in-solidity&#34;&gt;&#xA;  Main Gas optimization areas in solidity&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#main-gas-optimization-areas-in-solidity&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;storage&#34;&gt;&#xA;  Storage&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#storage&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Saving one variable in storage costs 20,000 gas&lt;/li&gt;&#xA;&lt;li&gt;5,000 gas when we rewrite the variable&lt;/li&gt;&#xA;&lt;li&gt;reading from the slot take 200 gas&lt;/li&gt;&#xA;&lt;li&gt;But storage variable declaration doesn&amp;rsquo;t cost anything, as there&amp;rsquo;s no initialization&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;tips&#34;&gt;&#xA;  Tips&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#tips&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;always save a storage variable in memory in a function&lt;/li&gt;&#xA;&lt;li&gt;if you wanna update a storage variable then first calculate everything in the memory variables&lt;/li&gt;&#xA;&lt;li&gt;organize &amp;amp; try to pack two or more storage variables into one it&amp;rsquo;s much cheaper&lt;/li&gt;&#xA;&lt;li&gt;also while using structs, try to pack them&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;refunds&#34;&gt;&#xA;  Refunds&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#refunds&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Free storage slot by zeroing corresponding variables as soon as you don&amp;rsquo;t need them anymore. This will refund 15,000 of gas.&lt;/li&gt;&#xA;&lt;li&gt;Removing a contract by using &lt;code&gt;Selfdestruct&lt;/code&gt; opcodes refunds 24,000 gas. But a refund must not surpass half the gas that the ongoing contract call uses.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;data-types-and-packing&#34;&gt;&#xA;  Data types and packing&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#data-types-and-packing&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use bytes32 whenever possible, because it is the most optimized storage type.&lt;/li&gt;&#xA;&lt;li&gt;If the length of bytes can be limited, use the lowest amount possible from bytes1 to bytes32.&lt;/li&gt;&#xA;&lt;li&gt;Using bytes32 is cheaper than using string&lt;/li&gt;&#xA;&lt;li&gt;Variable packing only occurs in storage — memory and call data does not get packed.&lt;/li&gt;&#xA;&lt;li&gt;You will not save space trying to pack function arguments or local variables&lt;/li&gt;&#xA;&lt;li&gt;Storing a small number in a uint8 variable is not cheaper than storing it in uint256 because the number in uint8 is padded with numbers to fill 32 bytes.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;inheritance&#34;&gt;&#xA;  Inheritance&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#inheritance&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;when we extend a contract, the variables in the child can be packed with the variables in the parent.&lt;/li&gt;&#xA;&lt;li&gt;The order of variables is determined by &lt;a href=&#34;https://en.wikipedia.org/wiki/C3_linearization&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C3 linearization&lt;/a&gt;, all you need to know is that child variables come after parent variables.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;memory-vs-storage&#34;&gt;&#xA;  Memory vs Storage&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#memory-vs-storage&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;copying between the memory and storage will cost some gas, so don&amp;rsquo;t copy arrays from storage to memory, use a &lt;a href=&#34;https://blog.b9lab.com/storage-pointers-in-solidity-7dcfaa536089&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;storage pointer&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;the cost of memory is complicated. you &amp;ldquo;buy&amp;rdquo; it in chunks, the cost of which will go up quadratically after a while&lt;/li&gt;&#xA;&lt;li&gt;Try adjusting the location of your variables by playing with the keywords &amp;ldquo;storage&amp;rdquo; and &amp;ldquo;memory&amp;rdquo;. Depending on the size and number of copying operations between Storage and memory, switching to memory may or may not give improvements. All this is because of varying memory costs. So optimizing here is not that obvious and every case has to be considered individually.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;&#xA;  Variables&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#variables&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Avoid public variables&lt;/li&gt;&#xA;&lt;li&gt;Use global variables efficiently&lt;/li&gt;&#xA;&lt;li&gt;it is good to use global variables with private visibility as it saves gas&lt;/li&gt;&#xA;&lt;li&gt;Use events rather than storing data&lt;/li&gt;&#xA;&lt;li&gt;Use memory arrays efficiently&lt;/li&gt;&#xA;&lt;li&gt;Use return values efficiently&lt;/li&gt;&#xA;&lt;li&gt;A simple optimization in Solidity consists of naming the return value of a function. It is not needed to create a local variable then.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;mapping-vs-array&#34;&gt;&#xA;  Mapping vs Array&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#mapping-vs-array&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use mapping whenever possible, it&amp;rsquo;s cheap instead of the array&lt;/li&gt;&#xA;&lt;li&gt;But an array could be a good choice if you have a small array&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;fixed-vs-dynamic&#34;&gt;&#xA;  Fixed vs Dynamic&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#fixed-vs-dynamic&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Fixed size variables are always cheaper than dynamic ones.&lt;/li&gt;&#xA;&lt;li&gt;It&amp;rsquo;s good to use memory arrays if the size of the array is known, fixed-size memory arrays can be used to save gas.&lt;/li&gt;&#xA;&lt;li&gt;If we know how long an array should be, we specify a fixed size&lt;/li&gt;&#xA;&lt;li&gt;This same rule applies to strings. A string or bytes variable is dynamically sized; we should use a byte32 if our string is short enough to fit.&lt;/li&gt;&#xA;&lt;li&gt;If we absolutely need a dynamic array, it is best to structure our functions to be additive instead of subtractive. Extending an array costs constant gas whereas truncating an array costs linear gas.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;&#xA;  Functions&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#functions&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;use external most of the time whenever possible&lt;/li&gt;&#xA;&lt;li&gt;Each position will have an extra 22 gas, so&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Reduce public variables&lt;/li&gt;&#xA;&lt;li&gt;Put often-called functions earlier&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;reduce the parameters if possible (Bigger input data increases gas because more things will be stored in memory)&lt;/li&gt;&#xA;&lt;li&gt;payable function saves some gas as compared to non-payable functions (as the compiler won&amp;rsquo;t have to check)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;view-functions&#34;&gt;&#xA;  View Functions&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#view-functions&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;You are not paying for view functions but this doesn&amp;rsquo;t mean they aren&amp;rsquo;t consuming gas, they do.&lt;/li&gt;&#xA;&lt;li&gt;it cost gas when calling in a tx&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;loops&#34;&gt;&#xA;  Loops&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#loops&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;use memory variables in loops&lt;/li&gt;&#xA;&lt;li&gt;try to avoid unbounded loops&lt;/li&gt;&#xA;&lt;li&gt;write uint256 index; instead of writing uint256 index = 0; as being a uint256, it will be 0 by default so you can save some gas by avoiding initialization.&lt;/li&gt;&#xA;&lt;li&gt;if you put &lt;code&gt;++&lt;/code&gt; before &lt;code&gt;i&lt;/code&gt; it costs less gas&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;operations&#34;&gt;&#xA;  Operations&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#operations&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;order&#34;&gt;&#xA;  Order&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#order&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Order cheap functions before&#xA;&lt;ul&gt;&#xA;&lt;li&gt;f(x) is cheap&lt;/li&gt;&#xA;&lt;li&gt;g(y) is expensive&lt;/li&gt;&#xA;&lt;li&gt;ordering should be&lt;/li&gt;&#xA;&lt;li&gt;f(x) || g(y)&lt;/li&gt;&#xA;&lt;li&gt;f(x) &amp;amp;&amp;amp; g(y)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;use-short-circuiting-rules-to-your-advantage&#34;&gt;&#xA;  Use Short-Circuiting rules to your advantage&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#use-short-circuiting-rules-to-your-advantage&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;When using logical disjunction (||), logical conjunction (&amp;amp;&amp;amp;), make sure to order your functions correctly for optimal gas usage. In logical disjunction (OR), if the first function resolves to true, the second one won’t be executed and hence save you gas. In logical disjunction (AND), if the first function evaluates to false, the next function won’t be evaluated. Therefore, you should order your functions accordingly in your solidity code to reduce the probability of needing to evaluate the second function.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
